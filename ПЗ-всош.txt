
Титульный лист
----------------




МАОУ Гимназия №10

Проект: «Бот для автоматизации отчетности по информационной безопасности в Telegram»

Ученик: О. Мария
Руководитель: (ФИО руководителя)
Класс: (указать)
Город: (указать)
Дата: 2025




Оглавление
----------------
1. ИСПОЛЬЗУЕМЫЕ ТЕРМИНЫ И СОКРАЩЕНИЯ — стр. 3
2. ВВЕДЕНИЕ — стр. 4
3. 1. ИССЛЕДОВАНИЕ ПРОБЛЕМЫ — стр. 5
3.1. Блок про предметную область — стр. 5
3.2. Описание проблемы — стр. 5
3.3. Актуальность проблемы — стр. 5
3.4. Анализ аналогичных решений — стр. 5
3.5. Аудитория проекта — стр. 6
4. 2. РЕШЕНИЕ ПРОБЛЕМЫ — стр. 6
4.1. Формализация проблемы — стр. 6
4.2. Описание алгоритма решения — стр. 6
4.3. Описание существующих алгоритмов — стр. 7
4.4. Нормативно-правовые аспекты — стр. 7
5. 3. ОПИСАНИЕ РЕАЛИЗАЦИИ — стр. 7
5.1. Техническое задание — стр. 7
5.2. Описание идеи проекта — стр. 8
5.3. Используемые технологии — стр. 9
5.4. Принцип работы — стр. 10
5.5. Доказательство работоспособности — стр. 12
5.6. Перспективы развития — стр. 14
6. ЗАКЛЮЧЕНИЕ — стр. 15
7. СПИСОК ЛИТЕРАТУРЫ — стр. 16
8. ПРИЛОЖЕНИЕ — стр. 18
(Номера страниц ориентировочные)








ИСПОЛЬЗУЕМЫЕ ТЕРМИНЫ И СОКРАЩЕНИЯ
----------------
- API — Application Programming Interface
- SIEM — Security Information and Event Management
- IDS/IPS — Intrusion Detection/Prevention System
- CSV — Comma-Separated Values
- DB — база данных
- PTB — python-telegram-bot
- cron — планировщик задач (в Linux)
- TLS — Transport Layer Security







ВВЕДЕНИЕ
----------------
Информационная безопасность (ИБ) является ключевой частью современной ИТ-инфраструктуры: рост числа кибератак, уязвимостей и инцидентов требует регулярного мониторинга и своевременной отчетности. Ручная подготовка отчетов занимает время и подвержена ошибкам. Цель проекта — автоматизировать сбор данных о состоянии безопасности и генерацию регулярных отчётов с отправкой в Telegram, что позволит ускорить реагирование и улучшить прозрачность процессов.

Цели:
- Разработать Telegram-бота, автоматически собирающего данные о состоянии безопасности и формирующего отчёты по расписанию.

Задачи:
- Спроектировать архитектуру системы и БД (sqlite3).
- Реализовать сбор данных из локальных логов и (при возможности) внешних API.
- Создать модуль генерации отчётов (Markdown).
- Настроить отправку отчётов в Telegram по расписанию.
- Провести тестирование и подготовить документацию.









1. ИССЛЕДОВАНИЕ ПРОБЛЕМЫ
----------------
1.1 Блок про предметную область
Кратко описываем основы мониторинга ИБ: зачем нужны метрики (сетевая активность, логи, уязвимости), роль отчётности для аналитики и принятия решений. Приводим определения: инцидент, уязвимость, показатель KPI безопасности (количество инцидентов/неделя, среднее время реакции).

1.2 Описание проблемы
В организациях отчётность часто формируется вручную: сбор логов с разных систем, ручная агрегация, подготовка отчётов в текстовом виде. Это долго и накладывает риск пропуска важных событий.

1.3 Актуальность проблемы
Приводим факты и ссылки (примерные источники, заменить реальными): рост числа уязвимостей и утечек в последние годы, экономические потери от инцидентов. (Дать 2–3 ссылки на статистику по кибератакам.)

1.4 Анализ аналогичных решений
- Коммерческие SIEM-системы (Splunk, Elastic SIEM): полнофункциональны, но сложны и дорого стоят.
- Скрипты и агентские решения (cron + сборщики логов): просты, но часто не имеют удобной системы оповещений.
- Telegram-боты для уведомлений: есть open-source проекты, использующие python-telegram-bot + DB для планирования (см. примеры в сети).
Вывод: для школьного проекта целесообразно сделать лёгкий бот с фокусом на автоматическую отчётность и простоту развёртывания.

1.5 Аудитория проекта
- Небольшие ИТ-отделы и администраторы: средняя/широкая.
- Школьные/учебные сетевые лаборатории: ограниченная, но релевантная.









2. РЕШЕНИЕ ПРОБЛЕМЫ
----------------
2.1 Формализация проблемы
Дано: набор источников данных S = {s1, s2, ...} (логи, API метрики). Требуется: функция R(t) — отчёт по времени t, который агрегирует метрики и представляет их в читаемом виде, рассылается в Telegram по расписанию cron_t.

2.2 Описание алгоритма решения
1) Сбор данных: периодически опрашивать источники или читать файлы логов.
2) Нормализация: привести данные к единому формату (timestamp, тип, значение).
3) Агрегация: вычисление KPI (число инцидентов, количество критических уязвимостей, топ-источников трафика).
4) Генерация отчёта: шаблон Markdown с секциями (Резюме, Метрики, Инциденты, Рекомендации).
5) Рассылка: отправить отчёт в Telegram-чат через Bot API в заданное время.

2.3 Описание существующих алгоритмов
Коротко перечислить: оконная агрегация (sliding window), пороговые правила для алертов, простая корреляция событий по IP/сессиям. Для проекта использовать простую агрегирующую логику (сводка за период).

2.4 Нормативно-правовые аспекты решения
- Работа с логами и персональными данными требует соблюдения локального законодательства (например, Федеральный закон «О персональных данных»), исключить чувствительные персональные данные из отчётов; хранение локально в sqlite3; права доступа к боту — только доверенные пользователи/группы.








3. ОПИСАНИЕ РЕАЛИЗАЦИИ
----------------
3.1 Техническое задание
Цель: реализовать Telegram-бота для автоматизированной генерации и отправки отчётов по ИБ.
Требования:
- Язык: Python 3.11.
- БД: sqlite3 для хранения метаданных, расписаний и истории отчётов.
- Планирование: встроенный JobQueue python-telegram-bot / cron.
- Формат отчёта: Markdown.
- Настройка: команды бота для управления расписанием (/set_report, /unset_report, /status).
- Развёртывание: Linux (без Docker).
Критерии приёмки:
- Автоматическая отправка отчёта по расписанию.
- Возможность ручной генерации и отправки отчёта.
- Логи работы и журнал отправок в БД.

3.2 Описание идеи проекта (TL;DR)
Бот агрегирует метрики безопасности из локальных логов и простых API, формирует читабельные Markdown-отчёты и отправляет их в Telegram согласно расписанию; администратор может управлять расписанием через команды бота.

3.3 Используемые технологии
Таблица: технология — назначение

| Технология | Назначение |
|---|---|
| Python 3.11 | Язык разработки |
| python-telegram-bot | Работа с Telegram Bot API, JobQueue |
| sqlite3 | Локальное хранение расписаний, истории отчётов |
| requests | Вызовы внешних API (при необходимости) |
| cron / systemd-timers | Опционально для внешнего планирования |
| Git | Контроль версий |
| pytest | Тестирование модулей |

3.4 Принцип работы (архитектура)
- Модули: collector.py (сбор данных), normalizer.py (нормализация), aggregator.py (агрегация метрик), report_gen.py (генерация Markdown), bot.py (интеграция с Telegram, планирование), db.py (работа с sqlite3), config.py.
- Схема: источники → collector → normalizer → sqlite3 (хранилище) → aggregator → report_gen → bot → Telegram.
(В приложении — диаграмма блоков)

3.5 Доказательство работоспособности
План тестирования:
- юнит-тесты для нормализатора и агрегатора (pytest) — примеры тест-кейсов;
- интеграционные тесты: симуляция логов (тестовые файлы) → полный цикл генерации отчёта;
- проверка расписания: ручная команда /send_now и автоматическая рассылка в заданное время.
Результаты (примерные): демонстрация отправки отчёта в тестовый Telegram-чат с корректным Markdown-форматом и заполненными метриками.

3.6 Перспективы развития проекта
- Подключение SIEM/SNMP/API других систем;
- Поддержка CSV/XLS/PDF-экспортов;
- Разграничение доступа и аутентификация (бот для администраторов);
- Визуализация (графики) с использованием matplotlib и отправка изображений в чат;
- Контейнеризация (Docker) и масштабирование.










РЕАЛИЗАЦИЯ — пример структуры проекта и ключевые фрагменты кода
----------------
Структура:
- project_root/
  - bot.py
  - collector.py
  - aggregator.py
  - report_gen.py
  - db.py
  - config.py
  - requirements.txt
  - tests/

config.py (пример)
```python
TELEGRAM_TOKEN = "ВАШ_ТОКЕН"
REPORT_CHAT_ID = -1001234567890  # ID группы или чата
DB_PATH = "security_reports.db"
REPORT_SCHEDULE = {"daily": "09:00"}  # пример
```

db.py (упрощённый)
```python
import sqlite3
from contextlib import closing

def init_db(path="security_reports.db"):
    with closing(sqlite3.connect(path)) as conn:
        cur = conn.cursor()
        cur.execute("""
        CREATE TABLE IF NOT EXISTS reports (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            created_at TEXT,
            period_start TEXT,
            period_end TEXT,
            content TEXT
        )
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS schedules (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            cron_expr TEXT,
            chat_id TEXT
        )
        """)
        conn.commit()
```

collector.py (пример чтения логов)
```python
import re
from datetime import datetime

LOG_PATTERN = re.compile(r'(?P<ts>\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})\s+(?P<level>\w+)\s+(?P<msg>.+)')

def parse_log_line(line):
    m = LOG_PATTERN.match(line)
    if not m:
        return None
    return {
        "timestamp": m.group("ts"),
        "level": m.group("level"),
        "message": m.group("msg")
    }

def collect_from_file(path, since=None):
    events = []
    with open(path, 'r', encoding='utf-8') as f:
        for ln in f:
            ev = parse_log_line(ln.strip())
            if ev:
                ts = datetime.fromisoformat(ev["timestamp"])
                if since and ts < since:
                    continue
                events.append(ev)
    return events
```

aggregator.py (пример агрегации)
```python
from collections import Counter
from datetime import datetime

def aggregate_events(events):
    levels = Counter(ev['level'] for ev in events)
    top_msgs = Counter(ev['message'] for ev in events).most_common(5)
    return {
        "total_events": len(events),
        "by_level": dict(levels),
        "top_messages": top_msgs
    }
```

report_gen.py (генерация Markdown)
```python
from datetime import datetime

def generate_markdown(agg, period_start, period_end):
    md = []
    md.append(f"# Отчет по информационной безопасности")
    md.append(f"Период: {period_start} — {period_end}\n")
    md.append(f"**Всего событий:** {agg['total_events']}\n")
    md.append("## По уровням:")
    for lvl, cnt in agg['by_level'].items():
        md.append(f"- **{lvl}**: {cnt}")
    md.append("\n## Топ сообщений:")
    for msg, cnt in agg['top_messages']:
        md.append(f"- {cnt}× {msg}")
    md.append("\n---\nСформировано автоматически ботом.")
    return "\n".join(md)
```

bot.py (ключевые части, использование JobQueue)
```python
import logging
from telegram.ext import ApplicationBuilder, CommandHandler, JobQueue
from config import TELEGRAM_TOKEN, REPORT_CHAT_ID
from report_gen import generate_markdown
from aggregator import aggregate_events
from collector import collect_from_file

logging.basicConfig(level=logging.INFO)

async def send_report(context):
    # пример: собрать логи за последние 24 часа
    from datetime import datetime, timedelta
    end = datetime.utcnow()
    start = end - timedelta(days=1)
    events = collect_from_file("logs/security.log", since=start)
    agg = aggregate_events(events)
    md = generate_markdown(agg, start.isoformat(), end.isoformat())
    await context.bot.send_message(chat_id=REPORT_CHAT_ID, text=md, parse_mode="Markdown")

def main():
    app = ApplicationBuilder().token(TELEGRAM_TOKEN).build()
    jq = app.job_queue
    # планируем ежедневную задачу в 09:00 UTC (пример)
    jq.run_daily(send_report, time=datetime.time(hour=9, minute=0))
    app.run_polling()

if __name__ == "__main__":
    main()
```










Тестирование
----------------
- Юнит: pytest для aggregator.aggregate_events и report_gen.generate_markdown.
- Интеграция: тестовые логи в tests/fixtures запустить полный цикл и проверить, что сообщение отправляется (в тесте можно мокать метод bot.send_message).









Инструкция по запуску (Linux)
----------------
1. Установить Python 3.11.
2. Создать виртуальное окружение:
```bash
python3.11 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```
3. Инициализировать БД:
```bash
python -c "from db import init_db; init_db('security_reports.db')"
```
4. Запустить бота:
```bash
python bot.py
```
(Убедитесь, что TELEGRAM_TOKEN и REPORT_CHAT_ID настроены в config.py)










Безопасность и приватность
----------------
- Хранение логов локально, доступ к файлам и БД ограничен правами ОС.
- В отчётах исключать персональные данные.
- Использовать TLS для взаимодействия с внешними API.







Заключение
----------------
В работе поставленные цели достигнуты: спроектирован и реализован Telegram-бот, автоматизирующий сбор простых метрик безопасности и формирование отчётов в формате Markdown с отправкой по расписанию. Проект пригоден для использования в малых средах и как учебная платформа для изучения мониторинга и автоматизации в области ИБ. Основные ограничения: упрощённая логика агрегации, отсутствие интеграции с крупными SIEM и визуализацией.









Список литературы (пример)
----------------
1. Документация python-telegram-bot — https://docs.python-telegram-bot.org
2. Руководства по мониторингу безопасности и SIEM (статьи, книги)
3. Федеральный закон «О персональных данных» (при необходимости указать референс)






Приложения
----------------
- Диаграмма архитектуры (блок-схема).
- Полный исходный код ключевых модулей (см. раздел «РЕАЛИЗАЦИЯ»).
- Примеры тестовых логов и результаты тестирования.
- Скриншоты отправленного отчёта в Telegram (должны быть добавлены после тестовой отправки).





Отдельная вкладка: команды бота (пользовательская инструкция)
----------------
- /set_report HH:MM — установить ежедневную отправку в указанное время.
- /unset_report — отменить отправку.
- /send_now — отправить отчёт немедленно.
- /status — показать текущее расписание и историю отправок.

Отладочный совет
----------------
При проблемах со временем отправки убедитесь, что час
